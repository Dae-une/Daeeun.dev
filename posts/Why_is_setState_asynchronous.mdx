---
title: setState는 비동기로 동작한다
date: 2023-01-31
summary: setState는 사실 비동기로 동작한다.
tags: ['react', '기본부터']
---

우리가 리액트 개발을하며 많이사용하는 `setState`가 비동기로 동작한다는 사실을 알고 계셨나요<br/>

```jsx
export default function App() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
    alert(count);
  };

  return (
    <div className="App">
      <button onClick={increment}>{count}</button>
    </div>
  );
}
```

위 코드의 버튼을 클릭하면 카운트가 1로 변경된 후 alert창이 뜰것이라 예상할 수 있습니다<br/>
하지만 실제 실행 결과는 예상과 다르게 나오게됩니다.

# [`Why is setState asynchronous?`](https://github.com/facebook/react/issues/11527) 번역

아래는 [`Why is setState asynchronous?`](https://github.com/facebook/react/issues/11527)의 번역본 입니다.

저는 setState가 비동기인 이유를 이해하려고 노력했지만 해답을 찾지 못했고 아마도 그것이 리액트 코드에 대한 역사적인 이유(아키텍처적인 문제)이고 아마도 지금은 바꾸기 어려울 것이라는 결론에 도달했습니다. 하지만 Dan은 분명한 이유가 있다고 했으니 궁금합니다.

어쨌거나, 저는 몇가지 이유를 생각해봤으나 너무 쉽게 반박할 수 있기 때문에 이 이유가 전부일 수는 없다고 생각합니다.

1. 비동기 렌더링에는 비동기 setState가 필요합니다.
   많은 사람들이 처음에는 렌더링 효율성 때문이라고 생각합니다. 하지만 저는 이것이 이 동작에 대한 이유라고 생각하지 않습니다. 왜냐하면 비동기 렌더링을 하는 동안 setState를 동기적으로 유지하는 것은 간단하다고 생각하기 때문입니다. 아래 코드는 예시입니다.

```jsx
Component.prototype.setState = (nextState) => {
  this.state = nextState;
  if (!this.renderScheduled) setImmediate(this.forceUpdate);
};
```

2. 어떤 상태가 렌더링되었는지 알기 위해서는 비동기 setState가 필요합니다.
   가끔 듣는 또 다른 주장은 요청된 상태가 아니라 렌더링된 상태에 대해 추론하기를 원한다는 것입니다. 그러나 저는 이 원칙도 많은 장점이 있는지 확신하지 못합니다. 개념적으로 저에게 이상하게 느껴집니다. 렌더링은 부작용(side effect)에 관한 것이고 상태는 사실(fact)에 관한 것입니다.

비슷한 예를 들어보자면, 인쇄할 때까지 자신이 작성한 워드 문서의 마지막 버전을 읽을 수 없다면 꽤 어색할 것입니다.(타이핑 했는데 자신이 타이핑 한 상태를 바로 읽지 못한다.)

저는 리액트 팀이 setState의 비동기적 특성이 종종 야기하는 혼란을 알고 있다는 것을 의심하지 않습니다. 따라서 현재 동작에 대한 또 다른 매우 좋은 이유가 있다고 생각합니다.

## Dan의 답변

먼저 우리들은 일괄 업데이트를 위해 재조정을 연기하는 것이 유힉하다는 것에 동의합니다.<br/>
이 의견에 동의 한다는 것은 `setState`를 사용해서 동기적으로 렌더링하면 많은 경우에 비효율적일 것이고,<br/>
업데이트를 여러 개 받을 가능성이 있는 경우 업데이트를 일괄 처리하는것이 좋다는 것입니다.

예를 들어, 브라우저 클릭 이벤트 핸들러가 있고 자식 및 부모 컴포넌트에서 모두 `setState`를 호출 했을 때,<br/>
우리는 자식 컴포넌트를 두번 렌더링하지 않고 dirty 상태로 표시한 다음 브라우저 이벤트가 종료하기 전에 자식과 부모를 함께 리렌더링 합니다.

당신이 묻는 것은 우리가 일괄처리를 똑같이 한 후에 재조정을 기다리지 않고 `setState` 업데이트를 즉시 반영할수 없냐는 것입니다.<br/>
하나의 분명한 대답이 있다고 생각하지 않지만 생각할 수 있는 몇 가지 이유가 있습니다.

### 내부 일관성 보장

상태는 동기적으로 업데이트 되더라도 Props는 업데이트 되지 않습니다.<br/>
부모 컴포넌트를 리렌더링하기 전에는 props를 알 수 없으며, 이를 동기적으로 수행하면 일괄처리 할 수 없습니다.

현재 리액트에서 제공하는 객체 (state,props,refs)는 내부적으로 서로 일관성이 있습니다.<br/>
즉, 이러한 객체를 사용하는 경우 완전히 조정된 트리를 참조하도록 보장됩니다.

만약 제안한대로, 상태만 사용할 때 동기적으로 처리한다면 이 패턴이 작동합니다.

```jsx
console.log(this.state.value); // 0
this.setState({ value: this.state.value + 1 });
console.log(this.state.value); // 1
this.setState({ value: this.state.value + 1 });
console.log(this.state.value); // 2
```

그러나 하나의 상태를 몇몇 하위 컴포넌트에서 같이 사용하기 위해 부모 컴포넌트로 이동해야 한다고 해보겠습니다.

```jsx
-this.setState({ value: this.state.value + 1 });
+this.props.onIncrement(); // Does the same thing in a parent
```

이것은 setState에 의존하는 일반적인 리액트 앱에서 가장 많이 수행하는 리팩토링 유형이라 생각합니다.

그러나 이것은 코드를 손상시킵니다.

```jsx
console.log(this.props.value); // 0
this.props.onIncrement();
console.log(this.props.value); // 0
this.props.onIncrement();
console.log(this.props.value); // 0
```

이것은 당신이 제안한 모델이 state는 처리 되지만 props는 처리되지 않기 때문입니다.<br/>
그리고 부모 컴포넌트를 리렌더링 하지 않고서는 props를 즉시 처리할 수 없습니다.<br/>
즉, 일괄 처리를 포기해야 합니다.(경우에 따라 성능이 크게 저하될 수 있음.)

이것에 대한 더 미묘한 케이스들도 있습니다.<br/>
예를 들어, 만약 여러분이 props(아직 반영되지 않음)와 state(제안해주신 것처럼 바로 반영)를 사용하여 새로운 state를 만드는 상황입니다.<br/>
Ref도 마찬가지 문제가 존재합니다[`#122`](https://github.com/facebook/react/issues/122#issuecomment-22659651)

그렇다면, 리액트에서는 이 문제를 어떻게 해결할까요?<br/>
리액트에서는 state와 props는 재조정 및 flush 후에만 업데이트 되므로 리팩토링 전후에 모두 0이 프린트 되는것을 볼 수 있습니다.<br/>
이렇게 하면 리프팅 상태가 안전해집니다.<br/>

이것은 경우에 따라 불편할 수도 있습니다.<br/>
특히 다양한 백그라운드를 가지고 있고 상태를 한번에 업데이트하기 보다 여러번 업데이트하고 싶어하는 분들에게 말이죠<br/>
저는 그것에 공감할 수 있지만, 상태 업데이트를 집중적으로 유지하는 것이 디버깅 관점에서 더 명확하다고 생각합니다.

작업 내용을 알고 있는 경우 트리 전체를 플러시할 수도 있습니다.<br/>
API는 `ReactDOM.flushSync(fn)`입니다.<br/>
실제로 호출 내부에서 발생하는 업데이트에 대해 완전한 리렌더링을 강제하므로 매우 드물게 사용해야 합니다.<br/>
이렇게 하면 state,props,refs 간의 내부 일관성 보장이 깨지지 않습니다.

> 요약 하자면, 리액트 모델이 항상 가장 간결한 코드로 이어지는 것은 아니지만, 내부적으로 일관되고 리프팅 상태가 안전하다는 것을 보장합니다.

### 동시 업데이트 활성화

개념적으로 리액트는 컴포넌트당 하나의 업데이트 대기열을 가진 것처럼 동작합니다.<br/>
우리는 업데이트가 정확한 순서로 적용될 것이라는 것을 의심하지 않기 때문에 state에 업데이트를 즉시 적용할지 여부를 논의합니다.<br/>

최근에 우리는 `비동기 렌더링`에 대해 많이 이야기하고 있습니다.<br/>
이것이 의미하는 바를 제대로 전달하지 못했다는 점은 인정하지만 이것이 R&D의 본질입니다.<br/>
개념적으로 유망해 보이는 아이디어를 추구하지만, 충분한 시간을 보낸 후에야 그 의미를 이해합니다.<br/>

우리가 `비동기 렌더링`을 설명하는 한 가지 방법은 리액트가 이벤트 핸들러, 네트워크 응답, 애니메이션 등의 출처에 따라<br/>
`setState`호출에 다른 우선순위를 할당할 수 있다는 것입니다.

예를 들어, 메세지를 입력하는 경우 TextBox컴포넌트의 setState 호출을 즉시 처리해야합니다.<br/>
그러나 입력하는 동안 새 메시지가 표시되면 스레드 차단으로 인해 입력이 더듬거리는 것보다 <br/>
새 메시지 버블의 렌더링을 특정 임계값(ex:1초)까지 지연하는 것이 더 나을 수 있습니다.

특정 업데이트에 낮은 우선 순위가 있다면, 그 렌더링을 몇 밀리초의 작은 청크로 분할하여 유저의 눈에 띄지않게 할 수 있습니다.

이와 같은 성능 최적화가 그다지 흥미롭거나 설득력있게 들리지 않을 수도 있다는 것을 알고 있습니다.

그러나 비동기 렌더링은 성능 최적화에 관한 것만은 아닙니다.<br/>
우리는 이것이 리액트 컴포넌트 모델이 할 수 있는 것의 근본적인 변화라고 생각합니다.

예를 들어서 한 화면에서 다른 화면으로 이동하는 경우를 보세요.

일반적으로 새 화면이 렌더링되는 동안 스피너를 표시합니다.<br/>
그러나 네비게이션 이동이 충분히 빠르면 스피너가 깜빡이고 즉시 숨겨져서 사용자 경험이 저하됩니다.<br/>
더 안좋은 경우, 서로 다른 비동기 종속성(데이터,이미지,코드)을 가진 여러 수준의 컴포넌트가 있는 경우<br/>
하나씩 짧게 깜빡이는 스피너를 볼 수 있습니다.<br/>
이것은 시각적으로 불쾌하고 모든 DOM reflow 때문에 실제로 앱을 느리게 만듭니다.<br/>

다른 뷰를 렌더링하는 간단한 setState를 수행할 때 백그라운드에서 업데이트된 뷰 렌더링을 시작할 수 있다면 좋지 않을까요?<br/>
조정 코드를 직접 작성하지 않고 업데이트가 특정 임계값 보다 오래걸리는 경우 스피너를 표시하도록 선택할 수 있고,<br/>
그렇지 않으면 전체 새 하위 트리의 비동기 종속성이 충족될 때 리액트가 원활한 전환을 수행할 수 있다고 상상해 보십시오.<br/>
게다가 우리가 대기 하는동안 오래된 화면은 대화형 상태(interactive)를 유지하고 리액트는 시간이 너무 오래 걸리면 스피너를 표시해야 합니다.<br/>

현재 [`리액트 모델과 생명주기에 대한 일부 조정`](https://github.com/reactjs/rfcs/pull/6)을 통해 실제로 이를 구현할 수 있습니다.<br/>

이것은 state가 즉시 처리되지 않기 때문에 가능합니다.<br/>
즉시 처리된다면, 이전 버전이 여전히 표시되고 상호작용하는 동안 백그라운드에서 뷰의 새버전을 렌더링할 방법이 없습니다.<br/>
그들의 독립된 상태 업데이트가 충돌하게 됩니다.<br/>

그리고 내가 이해하는 한, 적어도 부분적으로 이러한 유연성은 상태 업데이트를 즉시 처리하지 않기 때문에 가능합니다.

## 정리

위 내용을 정리해보자면, setState가 비동기적으로 설계된 이유는 아래와 같습니다.<br/>

### 리액트 내부의 일관성 보장

리액트에서 state,props,ref는 내부적으로 서로 일광성이 있으며,<br/>
이 의미는 이 객체들을 사용하는 경우 완전히 조정된 트리를 참조하도록 보장된다.

하위 컴포넌트에서 상위 컴포넌트의 상태를 바꿧을때, <br/>
동기적으로 반영이 된다 하더라도 상태를 props를 통해 하위 컴포넌트로 전달해주기 때문에<br/>
렌더링을 하지 않으면 업데이트된 상태를 전달해 줄수 없다.

만약 상태를 동기적으로 업데이트하면서 정확한 트리를 만들려면 상태를 업데이트할 때마다 <br/>
재조정을 해야하는데 이는 일괄처리를 할 수 없게된다.

### 동시성 기능

동시성이란 두개 이상의 독립적인 작업을 잘게 나누어 `Context Switching`을 하며 동시에 실행되는 것 처럼 보이도록 <br/>
프로그램을 구조화하는 방법이다.

동시성 기능을 활용하면 렌더링을 잘게 쪼개어 상테 업데이트에 우선순위를 다르게 두어 업데이트할 수 있다.<br/>
리액트는 이벤트 핸들러, 네트워크 응답, 애니메이션 등에 따라 setState 호출에 우선순위를 정할 수 있다.<br/>

이러한 동시성 기능이 가능하게 하려면 상태 업데이트를 동기적으로 수행하면 안된다.<br/>
상태 업데이트를 즉시 한다는 것은 그 작업의 수행 시간과는 관계 없이 큐처럼 순서대로 반영된다는 이야기이며,<br/>
이럴 경우 사용자 경험을 저하 시킬 수 있다.

아래는 setState의 코드이다.

```jsx
Component.prototype.setState = function (partialState, callback) {
  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```

# 참조

[`RFClarification: why is setState asynchronous?`](https://github.com/facebook/react/issues/11527)
